{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMultiDayState = exports.endsToday = exports.isResumingFromPast = exports.isStartingThisHour = exports.parseTime = exports.parseTimeUsingDate = void 0;\n\nvar _dateFns = require(\"date-fns\");\n\nvar _WeekEvent = require(\"../WeekEvent\");\n\nvar parseTimeUsingDate = function parseTimeUsingDate(_, originalValue, refDate, timeFormats) {\n  var parseAllowedFormats = function parseAllowedFormats() {\n    var parsed = timeFormats.map(function (format) {\n      return (0, _dateFns.parse)(originalValue, format, refDate);\n    }).filter(function (parsed) {\n      return (0, _dateFns.isValid)(parsed);\n    });\n    if (parsed.length === 0) return 'Invalid time';\n    return parsed[0];\n  };\n\n  return (0, _dateFns.isDate)(originalValue) ? originalValue : parseAllowedFormats();\n};\n\nexports.parseTimeUsingDate = parseTimeUsingDate;\n\nvar parseTime = function parseTime(_, originalValue, timeFormats) {\n  return parseTimeUsingDate(_, originalValue, new Date(), timeFormats);\n};\n\nexports.parseTime = parseTime;\n\nvar isStartingThisHour = function isStartingThisHour(event, hour) {\n  return (0, _dateFns.areIntervalsOverlapping)({\n    start: event.start,\n    end: (0, _dateFns.add)(event.start, {\n      seconds: 1\n    })\n  }, {\n    start: hour,\n    end: (0, _dateFns.add)(hour, {\n      hours: 1\n    })\n  });\n};\n\nexports.isStartingThisHour = isStartingThisHour;\n\nvar isResumingFromPast = function isResumingFromPast(event, hour) {\n  var isMidnight = hour.getHours() === 0;\n  if (isMidnight === false) return false;\n  var isEventFromPreviousDay = (0, _dateFns.isBefore)(event.start, hour);\n  if (isEventFromPreviousDay === false) return false;\n  var hasEventThisHour = (0, _dateFns.areIntervalsOverlapping)({\n    start: event.start,\n    end: event.end\n  }, {\n    start: hour,\n    end: (0, _dateFns.add)(hour, {\n      hours: 1\n    })\n  });\n  return hasEventThisHour;\n};\n\nexports.isResumingFromPast = isResumingFromPast;\n\nvar endsToday = function endsToday(event, hour) {\n  return (0, _dateFns.isSameDay)(hour, event.end);\n};\n\nexports.endsToday = endsToday;\n\nvar getMultiDayState = function getMultiDayState(event, hour) {\n  if (isResumingFromPast(event, hour) && endsToday(event, hour) === false) {\n    return _WeekEvent.MultidayState.MIDDLE_DAY;\n  }\n\n  if (isResumingFromPast(event, hour) && endsToday(event, hour)) {\n    return _WeekEvent.MultidayState.LAST_DAY;\n  }\n\n  return _WeekEvent.MultidayState.FIRST_DAY;\n};\n\nexports.getMultiDayState = getMultiDayState;","map":{"version":3,"sources":["../../../../../src/lib/components/weekPlanner/utils/timeHelper.ts"],"names":["parseTimeUsingDate","parseAllowedFormats","parsed","parseTime","isStartingThisHour","start","event","end","seconds","hours","isResumingFromPast","isMidnight","hour","isEventFromPreviousDay","hasEventThisHour","endsToday","getMultiDayState","MultidayState"],"mappings":"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","sourcesContent":["import {\n  add,\n  areIntervalsOverlapping,\n  isBefore,\n  isDate,\n  isSameDay,\n  isValid,\n  parse,\n} from 'date-fns'\nimport { MultidayState } from '../WeekEvent'\nimport WeekEvent from '../WeekEvent'\n\nexport const parseTimeUsingDate = (\n  _: any,\n  originalValue: any,\n  refDate: Date,\n  timeFormats: string[]\n): Date => {\n  const parseAllowedFormats = () => {\n    const parsed = timeFormats\n      .map((format) => parse(originalValue, format, refDate))\n      .filter((parsed) => isValid(parsed))\n    if (parsed.length === 0) return 'Invalid time'\n    return parsed[0]\n  }\n  return isDate(originalValue) ? originalValue : parseAllowedFormats()\n}\n\nexport const parseTime = (\n  _: any,\n  originalValue: any,\n  timeFormats: string[]\n): Date => {\n  return parseTimeUsingDate(_, originalValue, new Date(), timeFormats)\n}\n\nexport const isStartingThisHour = (event: WeekEvent, hour: Date): boolean => {\n  return areIntervalsOverlapping(\n    { start: event.start, end: add(event.start, { seconds: 1 }) },\n    { start: hour, end: add(hour, { hours: 1 }) }\n  )\n}\n\nexport const isResumingFromPast = (event: WeekEvent, hour: Date): boolean => {\n  const isMidnight = hour.getHours() === 0\n  if (isMidnight === false) return false\n  const isEventFromPreviousDay = isBefore(event.start, hour)\n  if (isEventFromPreviousDay === false) return false\n  const hasEventThisHour = areIntervalsOverlapping(\n    { start: event.start, end: event.end },\n    { start: hour, end: add(hour, { hours: 1 }) }\n  )\n  return hasEventThisHour\n}\n\nexport const endsToday = (event: WeekEvent, hour: Date): boolean => {\n  return isSameDay(hour, event.end)\n}\n\nexport const getMultiDayState = (\n  event: WeekEvent,\n  hour: Date\n): MultidayState => {\n  if (isResumingFromPast(event, hour) && endsToday(event, hour) === false) {\n    return MultidayState.MIDDLE_DAY\n  }\n  if (isResumingFromPast(event, hour) && endsToday(event, hour)) {\n    return MultidayState.LAST_DAY\n  }\n  return MultidayState.FIRST_DAY\n}\n"]},"metadata":{},"sourceType":"script"}